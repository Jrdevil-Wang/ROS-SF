@###############################################
@#
@# ROS message source code generation for C++
@#
@# EmPy template for generating <msg>.h files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@###############################################
// Generated by genheader.py from file @(spec.package)/@(spec.short_name).msg
// DO NOT EDIT!
@{
import genmsg.msgs
import gencpp
import genheader

cpp_namespace = '%s'%(spec.package) # TODO handle nested namespace
cpp_class = '%s'%spec.short_name
cpp_full_name = '%s::%s'%(cpp_namespace,cpp_class)
cpp_msg_definition = gencpp.escape_message_definition(msg_definition)
cpp_full_name_quotation = '"%s/%s"'%(cpp_namespace,cpp_class)
}@
#pragma once
@##############################
@# Generic Includes
@##############################

#include <stdio.h>  
#include <stdlib.h>
#include <string>
#include <string.h>
#include <memory>

#include "ros/ros.h"

@##############################
@# Includes for dependencies
@##############################
@{
vector_include = False
for field in spec.parsed_fields():
    if field.base_type == "string":
        print('#include "String_vec.h"')
    if (vector_include == False and field.is_array and field.array_len is None) :
        print('#include "Vec.h"')
        vector_include = True
    if (not field.is_builtin):
        if (field.is_header):
            print('#include "Header.h"')
        else:
            (package, name) = genmsg.names.package_resource_name(field.base_type)
            package = package or spec.package # convert '' to package
            if (not genheader.is_fixed_length(name, package, msg_context, search_path)):
                print('#include <%s.h>'%(name))
            else:
                print('#include <%s/%s.h>'%(package, name))
}@

#include "MemoryManager.h"

#include <iostream>

namespace @(cpp_namespace) {
class @(cpp_class) {
public:
@[for field in spec.parsed_fields()]
@{  cpp_type = genheader.msg_type_to_cpp(field.type, spec.package, msg_context, search_path)}@
  @(cpp_type) @(field.name);
@[end for]
  @(cpp_class)() {}
  ~@(cpp_class)() {}
    
  @(cpp_class)(const @(cpp_class) & m) {
    // std::cout << "Alert: Don't copy() @(cpp_namespace)::@(cpp_class)!\n";
    int32_t l1 = mm.get_msg_length((uint8_t *)this);
    int32_t l2 = mm.get_msg_length((uint8_t *)&m); // find length from memory manager
    mm.resize_msg_block((uint8_t *)this, l2 - l1);
    memcpy(this, &m, l2);
  }

  @(cpp_class) & operator=(const @(cpp_class) & m) {
    // std::cout << "Alert: Don't copy= @(cpp_namespace)::@(cpp_class)!\n";
    int32_t l1 = mm.get_msg_length((uint8_t *)this);
    int32_t l2 = mm.get_msg_length((uint8_t *)&m); // find length from memory manager
    mm.resize_msg_block((uint8_t *)this, l2 - l1);
    memcpy(this, &m, l2);
  }

  void * operator new(size_t size) {
    const uint32_t MAXLEN = MAX_LEN;
    uint8_t * start_shd = new uint8_t[MAXLEN];
    uint8_t * start_msg = start_shd + sizeof(SerializedHeader);
    mm.append_msg_block(start_msg, sizeof(Image), boost::shared_array<uint8_t>(start_shd));
    return start_msg;
  }

  void operator delete(void * p) {
    uint8_t * start_msg = (uint8_t *)p;
    mm.delete_msg_block(start_msg);
  }

  typedef boost::shared_ptr< ::@(cpp_namespace)::@(cpp_class) > Ptr;
  typedef boost::shared_ptr< ::@(cpp_namespace)::@(cpp_class) const> ConstPtr;

}; // class @(cpp_class)

typedef boost::shared_ptr< ::@(cpp_namespace)::@(cpp_class) > @(cpp_class)Ptr;
typedef boost::shared_ptr< ::@(cpp_namespace)::@(cpp_class) const> @(cpp_class)ConstPtr;

} // namespace @(cpp_namespace)

template<>
boost::shared_ptr<@(cpp_full_name)> boost::make_shared<@(cpp_full_name)>() {
  return boost::shared_ptr<@(cpp_full_name)>(new @(cpp_full_name));
}

@# Message Traits
namespace ros {
namespace message_traits {

@{
bool_traits = dict(
    IsFixedSize=gencpp.is_fixed_length(spec, msg_context, search_path),
    IsMessage=True,
    HasHeader=spec.has_header(),
)
def booltotype(b):
   return "TrueType" if b else "FalseType"
}

@# Binary traits

@[for k, v in bool_traits.items()]@

template <>
struct @(k)< ::@(cpp_full_name) >
  : @(booltotype(v)) { 
  };

template <>
struct @(k)< ::@(cpp_full_name) const>
  : @(booltotype(v)) { 
  };
@[end for]@

@# String traits
@[for trait_class,trait_value in [['MD5Sum', md5sum], ['DataType', cpp_full_name_quotation], ['Definition', cpp_msg_definition]]]@

template <>
struct @(trait_class)< ::@(cpp_full_name) > {
  static const char * value() {
    return @(trait_value);
  }

  static const char * value(const ::@(cpp_full_name) &) { 
    return value(); 
  }
@{
if trait_class == 'MD5Sum':
  iter_count = int(len(trait_value) / 16)
  for i in range(0, iter_count):
    start = i*16
    print('  static const uint64_t static_value%s = 0x%sULL;'%((i+1), trait_value[start:start+16]))
}@

};
@[end for]@

@# End of traits
} // namespace message_traits
} // namespace ros

@# Serialization
namespace ros
{
namespace serialization
{

template<>
inline SerializedMessage serializeMessage<@(cpp_full_name)>(const @(cpp_full_name) & message) {
  SerializedMessage m;

  @(cpp_full_name) * ptr_msg = (@(cpp_full_name) *)&message;
  uint8_t * start_msg = (uint8_t *)ptr_msg;
  uint8_t * start_shd = start_msg - sizeof(SerializedHeader);

  int32_t len = mm.get_msg_length(start_msg); // find length from memory manager
  m.num_bytes = len + sizeof(SerializedHeader);

  SerializedHeader * ptr_shd = (SerializedHeader *)start_shd;
  ptr_shd->len = len; // write length to serialized message

  m.buf = mm.get_msg_array(start_msg);
//  std::cout << "in ser: " << len << ", " << &message << "\n";
  return m;
}

} // namespace serialization

template<>
class SubscriptionCallbackHelperT<const boost::shared_ptr<@(cpp_full_name) const> &> : public SubscriptionCallbackHelper
{
public:
  typedef const boost::shared_ptr<@(cpp_full_name) const> & P;
  typedef ParameterAdapter<P> Adapter;
  typedef typename ParameterAdapter<P>::Message NonConstType;
  typedef typename ParameterAdapter<P>::Event Event;
  typedef typename boost::add_const<NonConstType>::type ConstType;
  typedef boost::shared_ptr<NonConstType> NonConstTypePtr;
  typedef boost::shared_ptr<ConstType> ConstTypePtr;

  static const bool is_const = ParameterAdapter<P>::is_const;

  typedef boost::function<void(typename Adapter::Parameter)> Callback;
  typedef boost::function<NonConstTypePtr()> CreateFunction;

  SubscriptionCallbackHelperT(const Callback& callback, 
			      const CreateFunction& create = DefaultMessageCreator<NonConstType>())
    : callback_(callback)
    , create_(create)
  { }

  void setCreateFunction(const CreateFunction& create)
  {
    create_ = create;
  }

  virtual bool hasHeader()
  {
     return message_traits::hasHeader<typename ParameterAdapter<P>::Message>();
  }

  virtual VoidConstPtr deserialize(const SubscriptionCallbackHelperDeserializeParams& params)
  {
    namespace ser = serialization;

    uint8_t * start_msg = params.buffer;
    int32_t len = params.length;

    mm.append_msg_block(start_msg, len, params.buf);

    @(cpp_full_name) * ptr_msg = (@(cpp_full_name) *)start_msg;
    NonConstTypePtr msg = boost::shared_ptr<@(cpp_full_name)>(ptr_msg);

    ser::PreDeserializeParams<NonConstType> predes_params;
    predes_params.message = msg;
    predes_params.connection_header = params.connection_header;
    ser::PreDeserialize<NonConstType>::notify(predes_params);

    return VoidConstPtr(msg);
  }

  virtual void call(SubscriptionCallbackHelperCallParams& params)
  {
    Event event(params.event, create_);
    callback_(ParameterAdapter<P>::getParameter(event));
  }

  virtual const std::type_info& getTypeInfo()
  {
    return typeid(NonConstType);
  }

  virtual bool isConst()
  {
    return ParameterAdapter<P>::is_const;
  }

private:
  Callback callback_;
  CreateFunction create_;
};

} // namespace ros