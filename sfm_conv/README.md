# ROS-SF Convertor

## Code Summary

`sfm_conv.cpp` is the main convertor code.

`/test` is a test to show how it works.

`/test/origin` is the code before conversion.

`/test/target` is the location for the code after conversion.

## Usage

### Compilation

Type `make` at the `/` directory to compile the `sfm_conv.cpp`.

LLVM 10.0 is needed to compile it.
On Ubuntu 20.04, `sudo apt install llvm-10-dev` should do the LLVM installation job.

### Conversion Test

Type `make` at the `/test` directory to compile the original version of the test.
The compilation should successfully generate an executable `/test/origin/a`.

Type `make sfm` at the `/test` directory to generate a converted version.
A `/test/target/a.cpp` is generated, which is the converted version of `/test/origin/a.cpp`.
Meanwhile, the compileation should successfully generate an executable `/test/target/a`.

Open `/test/origin/a.cpp` and `/test/target/a.cpp` to check their differences.

Type `./origin/a` to see the result.
Type `./target/a` to see the result after conversion.
They should behave the same.

### Advanced Usage

Currently, the message class name is written in the `sfm_conv.cpp`.
When using on other classes, such as `sensor_msgs::Image`, we need to modify the `sfm_conv.cpp`.

Three global variables should be modified.

- `use_dereivedtype` at line 34.

The default value is 0, indicating that the target class is with DICompositeType in LLVM.
Ordinary classes belong to this type.
When the target class is generated by a C++ template, set this value to 1, indicating that the target class is with DIDerivedType in LLVM.

- `strCls` at line 36.

This is the **full name** string of the target class.
Line 39 and line 43 give two examples.

- `strIdf` at line 37.

This is the **identifier name** string of the target class, which is the demangled C++ class name.
Line 40, line 41, line 44, and line 45 give four examples.
Note that when using line 40 and line 44, _use_dereivedtype_ should be set to 1.

After the above modification, re-compile the `sfm_conv.cpp`, and the generated executable `sfm_conv` can be used to convert other C++ code.

`/test/Makefile` gives an example of how to use `sfm_conv`.
Basicly, we need to compile the target `.cpp` file with LLVM (`clang++ -emit-llvm -c`) to generate a LLVM bitcode file (`.bc`).
Then run `sfm_conv a.bc a.cpp > a_mod.cpp` to convert `a.cpp` to `a_mod.cpp` with the help of `a.bc`.

Currently, this routine is not fully automated because it is related to the compilation process of the target project.
But it is trivial to achieve full automation by replacing the compiler to a tool based on the `sfm_conv`.
